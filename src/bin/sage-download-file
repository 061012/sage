#!/usr/bin/env python

#*****************************************************************************
#  Copyright (C) 2013  Volker Braun <vbraun.name@gmail.com>
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

import os
import sys
import urllib
import urlparse



def http_error_default(url, fp, errcode, errmsg, headers):
    """
    Callback for the URLopener to raise an exception on HTTP errors
    """
    fp.close()
    raise IOError(errcode, errmsg, url)


class ProgressBar(object):
    """
    Progress bar as urllib reporthook
    """

    def __init__(self, length=60):
        self.length = length
        self.progress = 0
        self.stream = sys.stderr

    def start(self):
        sys.stdout.flush()    # make sure to not interleave stdout/stderr
        self.stream.write('[')
        self.stream.flush()

    def __call__(self, chunks_so_far, chunk_size, total_size):
        if total_size == -1:  # we do not know size
            n = 0 if chunks_so_far == 0 else self.length / 2
        else:
            n = chunks_so_far * chunk_size * self.length / total_size
        if n > self.length: 
            # If there is a Content-Length, this will be sent as the last progress
            return
        # n ranges from 0 to length*total (exclude), so we'll print at most length dots
        if n >= self.progress:
            self.stream.write('.' * (n-self.progress))
            self.stream.flush()
        self.progress = n
        
    def stop(self):
        missing = '.' * (self.length - self.progress)
        self.stream.write(missing + ']\n')
        self.stream.flush()

    def error_stop(self):
        missing = 'x' * (self.length - self.progress)
        self.stream.write(missing + ']\n')
        self.stream.flush()
        

def http_download(url, destination=None, progress=True):
    """
    Download via HTTP

    INPUT:

    - ``url`` -- string. The URL to download.

    - ``destination`` -- string or ``None`` (default). The destination
      file name to save to. If not specified, the file is written to
      stdout.

    - ``progress`` -- boolean (default: ``True``). Whether to print a
      progress bar to stderr.
    """
    if destination is None:
        destination = '/dev/stdout'
    opener = urllib.FancyURLopener()
    opener.http_error_default = http_error_default
    if progress:
        progress_bar = ProgressBar()
        progress_bar.start()
        try:
            filename, info = opener.retrieve(url, destination, progress_bar)
        except IOError:
            progress_bar.error_stop()
            raise
        else:
            progress_bar.stop()
    else:
        filename, info = opener.retrieve(url, destination)



def upstream_directory():
    upstream = os.path.join(os.environ['SAGE_ROOT'], 'upstream')
    try:
        os.mkdir(upstream)
    except OSError:
        pass
    return upstream


class MirrorList(object):
    
    URL = 'http://www.sagemath.org/mirror_list'

    MAXAGE = 24*60*60   # seconds

    def __init__(self):
        self.filename = os.path.join(upstream_directory(), 'mirror_list')
        if self.must_refresh():
            print('Downloading the Sage mirror list')
            http_download(self.URL, self.filename)
            self.mirrors = self._load()
            self._rank_mirrors()
            self._save()
        else:
            self.mirrors = self._load()

    def _load(self):
        """
        Load and return the current mirror list as a list of strings
        """
        with open(self.filename, 'rt') as f:
            mirror_list = f.read()
        import ast
        return ast.literal_eval(mirror_list)

    def _save(self):
        """
        Save the mirror list for (short-term) future  use.
        """
        with open(self.filename, 'wt') as f:
            f.write(repr(self.mirrors))

    def _port_of_mirror(self, mirror):
        if mirror.startswith('http://'):
            return 80
        if mirror.startswith('https://'):
            return 443
        if mirror.startswith('ftp://'):
            return 21

    def _rank_mirrors(self):
        """
        Sort the mirrors by speed, fastest being first

        This method is used by the YUM fastestmirror plugin 
        """
        timed_mirrors = []
        import time, socket
        print('Searching fastest mirror')
        timeout = 1
        for mirror in self.mirrors:
            port = self._port_of_mirror(mirror)
            mirror_hostname = urlparse.urlsplit(mirror).netloc
            time_before = time.time()
            try:
                sock = socket.create_connection((mirror_hostname, port), timeout)
                sock.close()
            except (IOError, socket.error, socket.timeout):
                continue
                print(str('ERROR').rjust(5) + '    ' + mirror)
            result = time.time() - time_before
            result_ms = int(1000 * result)
            print(str(result_ms).rjust(5) + 'ms: ' + mirror)
            timed_mirrors.append((result, mirror))
        timed_mirrors.sort()
        self.mirrors = [m[1] for m in timed_mirrors]
        print('Fastest mirror: ' + self.mirrors[0])

    @property
    def fastest(self):
        return self.mirrors[0]

    def age(self):
        """
        Return the age of the cached mirror list in seconds
        """
        import time
        mtime = os.path.getmtime(self.filename)
        now = time.mktime(time.localtime())
        return now - mtime

    def must_refresh(self):
        """
        Return whether we must download the mirror list.

        If and only if this method returns ``False`` is it admissible
        to use the cached mirror list.
        """
        if not os.path.exists(self.filename):
            return True
        return self.age() > self.MAXAGE

    def __iter__(self):
        for mirror in self.mirrors:
            yield mirror
        


class ChecksumError(Exception):
    pass

class FileNotMirroredError(Exception):
    pass


class Tarball(object):
    
    def __init__(self, tarball_name):
        """
        A (third-party downloadable) tarball

        INPUT:

        - ``name`` - string. The full filename (``foo-1.3.tar.bz2``)
          of a tarball on the Sage mirror network.
        """
        self.filename = tarball_name
        self.base, self.verson, self.ext = self._parse_name(tarball_name)
        self._init_checksum()

    @property
    def package(self):
        """
        Return the package name (the subdirectory of ``build/pkgs/``)
        """
        return self.base.lower()

    @property
    def upstream_fqn(self):
        """
        The fully-qualified (including directory) file name in the upstream directory.
        """
        return os.path.join(upstream_directory(), self.filename)

    def _parse_name(self, name):
        """
        Parse the tarball name into base, version, and extension
        """
        import re
        regex = re.compile('(?P<base>[a-zA-Z_]*)-(?P<version>.*)\.(?P<ext>tar.*)')
        return regex.match(name).groups()

    def _init_checksum(self):
        """
        Load the checksums from the appropriate ``checksums.ini`` file
        """
        import re
        SAGE_ROOT = os.environ['SAGE_ROOT']
        pkg_dir = os.path.join(SAGE_ROOT, 'build', 'pkgs', self.package)
        checksums_ini = os.path.join(pkg_dir, 'checksums.ini')
        assignment = re.compile('(?P<var>[a-zA-Z0-9]*)=(?P<value>.*)')
        result = dict()
        with open(checksums_ini, 'rt') as f:
            for line in f.readlines():
                match = assignment.match(line)
                if match is None:
                    continue
                var, value = match.groups()
                result[var] = value
        self.md5 = result['md5']
        self.sha1 = result['sha1']
        self.cksum = result['cksum']
        self.sha1 = result['sha1']
        
    def _compute_hash(self, algorithm):
        with open(self.upstream_fqn, 'rb') as f:
            while True:
                buf = f.read(0x100000)
                if not buf:
                    break
                algorithm.update(buf)
        return algorithm.hexdigest()

    def _compute_sha1(self):
        import hashlib
        return self._compute_hash(hashlib.sha1())

    def _compute_md5(self):
        import hashlib
        return self._compute_md5(hashlib.md5())
    
    def checksum_verifies(self):
        """
        Test whether the checksum of the downloaded file is correct.
        """
        sha1 = self._compute_sha1()
        return sha1 == self.sha1

    def download(self, mirror_list):
        """
        Download the tarball to the upstream directory.
        """
        destination = os.path.join(upstream_directory(), self.filename)
        if os.path.isfile(destination):
            if self.checksum_verifies():
                print('Using cached file $SAGE_ROOT/upstream/'+self.filename)
                return
            else:
                # Garbage in the upstream directory? Delete and re-download
                print('Invalid checksum for cached file $SAGE_ROOT/upstream/'+self.filename)
                os.remove(destination)
        successful_download = False
        for mirror in mirror_list:
            url = mirror + '/'.join(['spkg', 'upstream', self.package, self.filename])
            print(url)
            try:
                http_download(url, self.upstream_fqn)
                successful_download = True
                break
            except IOError:
                pass  # mirror doesn't have file for whatever reason...
        if not successful_download:
            raise FileNotMirroredError('tarball does not exist on mirror')
        if not self.checksum_verifies():
            raise ChecksumError('checksum does not match')

    def save_as(self, destination):
        import shutil
        shutil.copy(self.upstream_fqn, destination)


usage = \
"""
USAGE:

    sage-download-file [--quiet] url-or-tarball [destination]

The single mandatory argument can be a http:// or ftp:// url or a
tarball filename. In the latter case, the tarball is downloaded from
the mirror network and its checksum is verified.

If the destination is not specified:
* a url will be downloaded and the content written to stdout
* a tarball will be saved under $SAGE_ROOT/upstream
"""


if __name__ == '__main__':
    progress = True
    url = None
    destination = None
    for arg in sys.argv[1:]:
        if arg.startswith('--quiet'):
            progress = False
            continue
        if url is None:
            url = arg
            continue
        if destination is None:
            destination = arg
            continue
        raise ValueError('too many arguments')
    if url is None:
        print(usage)
        sys.exit(1)
    if url.startswith('http://') or url.startswith('https://') or url.startswith('ftp://'):
        http_download(url, destination, progress=progress)
    else:
        # url is a tarball name
        mirror_list = MirrorList()
        tarball = Tarball(url)
        tarball.download(mirror_list)
        if destination is not None:
            tarball.save_as(destination)
        
    
    

# Usage: sage-download-file URL
# Download URL to standard output, using either wget, curl, Python's
# urllib or a custom program $URL_GRABBER.
#
# AUTHORS:
#
# - William Stein: original sage-download_package Python script
#
# - Leif Leonhardy, Jeroen Demeyer (Trac #13373): use wget, curl or Python
#
#*****************************************************************************
#  Distributed under the terms of the GNU General Public License (GPL)
#  as published by the Free Software Foundation; either version 2 of
#  the License, or (at your option) any later version.
#                  http://www.gnu.org/licenses/
#*****************************************************************************

# if [ $# -ne 1 ]; then
# cat >&2 <<EOF
# Usage: $0 URL

# Download URL to standard output, using either wget, curl, Python's
# urllib or a custom program $URL_GRABBER.
# EOF
# exit 2
# fi

# if [ -z "$URL_GRABBER" ]; then
#     # Prefer Sage's Python because that's the same on all systems.
#     # It should always work.
#     if [ -n "$SAGE_LOCAL" ] && [ -x "$SAGE_LOCAL/bin/python" ]; then
#         URL_GRABBER="$SAGE_LOCAL/bin/python"
#     elif command -v curl &>/dev/null; then
#         URL_GRABBER="curl --fail"
#     elif command -v wget &>/dev/null; then
#         URL_GRABBER="wget -nv -O-"
#     # Pick Python last because we don't know which version it is,
#     # so it's a bit risky.
#     elif command -v python &>/dev/null; then
#         URL_GRABBER="python"
#     else
#         echo >&2 "Error: $0: No program to fetch files from the web found."
#         echo >&2 "       Either install Wget, curl or Python, or set the environment"
#         echo >&2 "       variable URL_GRABBER to use some alternate, installed program."
#         echo >&2 "       In the latter case, add options to download the contents of the"
#         echo >&2 "       specified URL to the standard output. URL_GRABBER can also be"
#         echo >&2 "       a Python interpreter."
#         exit 3
#     fi
# fi


# # Is $URL_GRABBER a Python interpreter?
# if ! ( $URL_GRABBER --version </dev/null 2>&1 | grep '^Python ' ) &>/dev/null ; then
#     # Not Python, simply execute it
#     exec $URL_GRABBER "$1"
# fi


# # Use Python
# exec $URL_GRABBER <<EOF

# ##############################################
# # Python script to download a file to stdout #
# ##############################################

# import sys, urllib

# # Change the URLopener to raise an exception on HTTP errors
# def http_error_default(url, fp, errcode, errmsg, headers):
#     fp.close()
#     raise IOError(errcode, errmsg, url)

# opener = urllib.FancyURLopener()
# opener.http_error_default = http_error_default

# # This reporthook is used below to print ...'s as the file downloads.
# global cur
# cur = 0
# def reporthook(block, size, total):
#     global cur
#     n = 60*block*size
#     # n ranges from 0 to 60*total, so we'll print at most 60 dots
#     if n >= cur + total:
#         sys.stderr.write('.')
#         sys.stderr.flush()
#         cur += total
# sys.stderr.write('[')
# sys.stderr.flush()
# filename, info = opener.retrieve('''$1''', '/dev/stdout', reporthook)
# sys.stderr.write(']\n')
# EOF
