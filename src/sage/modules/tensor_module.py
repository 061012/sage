r"""
Tensor Algebras

AUTHORS:

- Travis Scrimshaw (2014-01-24): Initial version
"""

#*****************************************************************************
#  Copyright (C) 2014 Travis Scrimshaw <tscrim at ucdavis.edu>
#
#  Distributed under the terms of the GNU General Public License (GPL)
#                  http://www.gnu.org/licenses/
#*****************************************************************************

from sage.categories.graded_modules_with_basis import GradedModulesWithBasis
from sage.categories.modules_with_basis import ModulesWithBasis
from sage.categories.tensor import tensor
from sage.categories.morphism import Morphism
from sage.categories.homset import Hom
from sage.combinat.free_module import CombinatorialFreeModule, CombinatorialFreeModule_Tensor
from sage.monoids.indexed_monoid import IndexedFreeMonoid
from sage.misc.cachefunc import cached_method

class TensorModule(CombinatorialFreeModule):
    r"""
    The tensor module `T(M)` of a module `M`.

    Let `\{ b_i \}` be a basis of `M`, then the tensor module is the span of
    `\{ b_{i_1} \otimes b_{i_2} \otimes \cdots \otimes b_{i_k} \}`.

    .. SEEALSO::

        :class:`TensorModule`

    EXAMPLES::

        sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
        sage: TC = TensorModule(C)
        sage: TC.dimension()
        +Infinity
    """
    def __init__(self, M, prefix='T', category=None, **options):
        r"""
        Initialize ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: TestSuite(TC).run()
        """
        self._base_module = M
        R = M.base_ring()
        category = GradedModulesWithBasis(R).or_subcategory(category)

        CombinatorialFreeModule.__init__(self, R, IndexedFreeMonoid(M.indices()),
                                         prefix=prefix, category=category, **options)

        # the following is not the best option, but it's better than nothing.
        self._print_options['tensor_symbol'] = options.get('tensor_symbol', tensor.symbol)

    def _repr_(self):
        r"""
        Return a string representation of ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TensorModule(C)
            Tensor Module of Free module generated by {'a', 'b', 'c'} over Rational Field
        """
        return "Tensor Module of {}".format(self._base_module)

    def _repr_term(self, m):
        """
        Return a string of representation of the term indexed by ``m``.

        TESTS::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: s = TC.an_element().leading_support()
            sage: TC._repr_term(s)
            "B['a'] # B['b'] # B['c']"
            sage: s = TC(['a']*3 + ['b']*2 + ['a','c','b']).leading_support()
            sage: TC._repr_term(s)
            "B['a'] # B['a'] # B['a'] # B['b'] # B['b'] # B['a'] # B['c'] # B['b']"

            sage: I = TC.indices()
            sage: TC._repr_term(I.one())
            '1'
        """
        if len(m) == 0:
            return '1'
        symb = self._print_options['tensor_symbol']
        if symb is None:
            symb = tensor.symbol
        return symb.join(self._base_module._repr_term(k) for k,e in m._monomial for i in range(e))

    def _latex_term(self, m):
        r"""
        Return a latex of representation of the term indexed by ``m``.

        TESTS::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: s = TC.an_element().leading_support()
            sage: TC._latex_term(s)
            'B_{a} \\otimes B_{b} \\otimes B_{c}'

            sage: I = TC.indices()
            sage: TC._latex_term(I.one())
            '1'
        """
        if len(m) == 0:
            return '1'
        symb = " \\otimes "
        return symb.join(self._base_module._latex_term(k) for k,e in m._monomial for i in range(e))

    def _ascii_art_term(self, m):
        """
        Return an ascii art of representation of the term indexed by ``m``.

        TESTS::

            sage: C = CombinatorialFreeModule(QQ, Partitions())
            sage: TC = TensorModule(C)
            sage: s = TC([Partition([3,2,2,1]), Partition([3])]).leading_support()
            sage: TC._ascii_art_term(s)
            B    # B
             ***    ***
             **
             **
             *
            sage: s = TC([Partition([3,2,2,1])]*2 + [Partition([3])]*3).leading_support()
            sage: TC._ascii_art_term(s)
            B    # B    # B    # B    # B
             ***    ***    ***    ***    ***
             **     **
             **     **
             *      *

            sage: I = TC.indices()
            sage: TC._ascii_art_term(I.one())
            '1'
        """
        if len(m) == 0:
            return '1'
        from sage.misc.ascii_art import AsciiArt
        symb = self._print_options['tensor_symbol']
        if symb is None:
            symb = tensor.symbol
        M = self._base_module

        it = iter(m._monomial)
        k,e = it.next()
        rpr = M._ascii_art_term(k)
        for i in range(e-1):
            rpr += AsciiArt([symb], [len(symb)])
            rpr += M._ascii_art_term(k)
        for k,e in it:
            for i in range(e):
                rpr += AsciiArt([symb], [len(symb)])
                rpr += M._ascii_art_term(k)
        return rpr

    def _element_constructor_(self, x):
        """
        Construct an element of ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: TC.an_element()
            B['a'] # B['b'] # B['c']
            sage: TC.an_element() + TC(['a'])
            B['a'] # B['b'] # B['c'] + B['a']
            sage: TC.an_element() + TC(['a','b','a'])
            B['a'] # B['b'] # B['c'] + B['a'] # B['b'] # B['a']
            sage: TC.an_element() + TC(['a','b','c'])
            2*B['a'] # B['b'] # B['c']
            sage: TC(C.an_element())
            2*B['a'] + 2*B['b'] + 3*B['c']
        """
        FM = self._indices
        if isinstance(x, (list, tuple)):
            x = FM.prod(FM.gen(elt) for elt in x)
            return self.monomial(x)
        if x in FM._indices:
            return self.monomial(FM.gen(x))
        if x in self._base_module:
            return self.sum_of_terms((FM.gen(k), v) for k,v in x)
        return CombinatorialFreeModule._element_constructor_(self, x)

    def degree_on_basis(self, m):
        """
        Return the degree of the simple tensor ``m``, which is it's length
        (thought of as an element in the free monoid).

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: s = TC.an_element().leading_support(); s
            F['a']*F['b']*F['c']
            sage: TC.degree_on_basis(s)
            3
        """
        return m.length()

    def base_module(self):
        """
        Return the base module of ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: TC.base_module() is C
            True
        """
        return self._base_module

    def algebra(self):
        """
        Return the algebra of ``self``.

        EXAMPLES::

            sage: C = CombinatorialFreeModule(QQ, ['a','b','c'])
            sage: TC = TensorModule(C)
            sage: TC.algebra()
            Tensor Algebra of Free module generated by {'a', 'b', 'c'} over Rational Field
        """
        from sage.algebras.tensor_algebra import TensorAlgebra
        return TensorAlgebra(self._base_module, **self._print_options)

    def _tensor_constructor_(self, elts):
        """
        Construct an element of ``self`` from the list of base module
        elements ``elts``.

        TESTS::

            sage: C = CombinatorialFreeModule(ZZ, ['a','b'])
            sage: TC = TensorModule(C)
            sage: x = C.an_element(); x
            2*B['a'] + 2*B['b']
            sage: TC._tensor_constructor_([x, x])
            4*B['a'] # B['a'] + 4*B['b'] # B['b'] + 4*B['b'] # B['a'] + 4*B['a'] # B['b']
        """
        if len(elts) == 0:
            return self.zero()

        I = self._indices
        cur = {I.gen(k):v for k,v in elts[0]}
        for x in elts[1:]:
            next = {}
            for k,v in cur.items():
                for m,c in x:
                    i = k * I.gen(m)
                    next[i] = cur.get(i, 0) + v * c
            cur = next
        return self._from_dict(cur)

    def _coerce_map_from_(self, R):
        """
        Return ``True`` if there is a coercion from ``R`` into ``self`` and
        ``False`` otherwise.  The things that coerce into ``self`` are:

        - Anything with a coercion into ``self.base_ring()``.

        - Anything with a coercion into the base module of ``self``.

        - A tensor module whose factors have a coercion into the
          the base module of ``self``.

        TESTS::

            sage: C = CombinatorialFreeModule(ZZ, Set([1,2]))
            sage: TMC = TensorModule(C)
            sage: TMC.has_coerce_map_from(ZZ)
            True
            sage: TMC.has_coerce_map_from(C)
            True

            sage: TCC = tensor((C,C))
            sage: TMC.has_coerce_map_from(TCC)
            True

        ::

            sage: D = CombinatorialFreeModule(ZZ, Set([2,4]))
            sage: TMD = TensorModule(D)
            sage: f = C.module_morphism(on_basis=lambda x: D.monomial(2*x), codomain=D)
            sage: f.register_as_coercion()

            sage: TCD = tensor((C,D))
            sage: TMD.has_coerce_map_from(TCC)
            True
            sage: TMD.has_coerce_map_from(TCD)
            True
            sage: TMC.has_coerce_map_from(TCD)
            False
            sage: TMD.has_coerce_map_from(TMC)
            True
        """
        # Base ring coercions
        if self.base_ring() == R:
            return BaseRingLift(Hom(self.base_ring(), self))
        if self.base_ring().has_coerce_map_from(R):
            return BaseRingLift(Hom(self.base_ring(), self)) * self.base_ring().coerce_map_from(R)

        M = self._base_module
        # Base module coercions
        if R == M:
            return True
        if M.has_coerce_map_from(R):
            phi = M.coerce_map_from(R)
            return self.coerce_map_from(M) * phi

        # Tensor module coercions
        if isinstance(R, TensorModule) and M.has_coerce_map_from(R._base_module):
            RM = R._base_module
            phi = M.coerce_map_from(RM)
            return R.module_morphism(lambda m: self._tensor_constructor_(
                                               [phi(RM.monomial(k)) for k in m.to_word_list()]),
                                     codomain=self)

        # Coercions from tensor products
        if R in ModulesWithBasis(self.base_ring()).TensorProducts() \
                and isinstance(R, CombinatorialFreeModule_Tensor) \
                and all(M.has_coerce_map_from(RM) for RM in R._sets):
            modules = R._sets
            vector_map = [M.coerce_map_from(RM) for RM in R._sets]
            return R.module_morphism(lambda x: self._tensor_constructor_(
                                               [vector_map[i](M.monomial(x[i]))
                                                for i,M in enumerate(modules)]),
                                     codomain=self)

        return super(TensorModule, self)._coerce_map_from_(R)

class BaseRingLift(Morphism):
    """
    Morphism which lifts the base ring of a tensor module `T(M)` into `T(M)`
    to the `0`-th graded part.
    """
    def _call_(self, x):
        """
        Construct the element from ``x``.

        TESTS::

            sage: C = CombinatorialFreeModule(QQ, Set([1,2]))
            sage: TC = TensorModule(C)
            sage: TC(ZZ(2)) # indirect doctest
            2
        """
        T = self.codomain()
        R = T.base_ring()
        return T.term(T.indices().one(), R(x))

